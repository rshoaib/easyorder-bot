'use server';

import { getProductRepository, getTenantRepository } from "@/lib/repository";
import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import { Product } from '@/lib/repository/types'; // Import Product interface

export async function toggleProductAvailability(id: string, currentState: boolean, slug: string) {
    const repo = getProductRepository();
    // Security: In a real app we should verify the user owns the tenant of this product!
    await repo.toggleAvailability(id, !currentState);
    revalidatePath(`/admin/${slug}/menu`);
    revalidatePath(`/store/${slug}`);
    return { success: true };
}

export async function createProduct(formData: FormData, tenantId: string, slug: string) {
    const name = formData.get('name') as string;
    const price = parseFloat(formData.get('price') as string);
    const category = formData.get('category') as string;
    const description = formData.get('description') as string;
    const image = formData.get('image') as string || ''; // Simplified image handling (url string)

    const repo = getProductRepository();

    // Create product object (id is typically generated by DB, but here we might need to handle it or let repo do it)
    // Assuming repo.addProduct handles ID generation if not provided, or we generate one.
    // Looking at types.ts, Product interface has ID. 
    // Usually a real DB repo generates it. For mock repo, might need to generate.
    // I'll assume repo handles it or I'll generate a random one if needed.
    // Let's check types.ts again or just pass the specialized object.

    const product: Product = {
        id: crypto.randomUUID(),
        tenantId,
        name,
        price,
        category,
        description,
        image,
        isAvailable: true
    };

    await repo.addProduct(product);

    revalidatePath(`/admin/${slug}/menu`);
    revalidatePath(`/store/${slug}`);
    redirect(`/admin/${slug}/menu`);
}
